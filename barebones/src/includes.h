/*
Core depedent 
    printf     

SIMD defines too 

could use abs () 

METTRE A JOUR LES METRIQUES

*/

// DUR
#define codw_N 1024


// #define BASE_FUNC_32b
// #define EXT_FUNC_32b


// #define CUSTOM_BASE_FUNC_8b 
// #define CUSTOM_FUNC_4x8b 

#include <stdio.h>
#include <stdint.h>

// HARD 
#define K 512
char fb_table_tileN_origi[]={
4,4,4,2,4,2,4,4,0,4,0,4,4,4,0,4,4,4,3,4,4,4,0,4,0,4,0,4,4,4,2,4,2,4,4,4,2,4,4,4,1,4,4,4,2,4,2,4,4,4,4,3,4,3,1,4,4,4,4,3,4,3,1,1,4,4,4,4,2,4,2,4,2,4,4,4,2,4,2,4,4,4,4,3,4,3,1,4,4,4,4,0,4,4,4,3,4,4,4,3,4,3,1,4,4,4,4,1,1,1,4,4,4,4,4,2,4,4,4,3,4,4,4,1,1,4,4,4,3,1,1,1,4,4,4,4,3,1,1,1,1,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
};

char* fb_table_tileN = fb_table_tileN_origi ; 

char froozen_bits[]={
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,1,1,0,1,0,0,0,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,0,1,0,0,0,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,0,1,0,0,0,1,0,0,0,0,0,0,0,1,1,1,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,1,1,1,0,1,0,0,0,1,1,1,0,1,0,0,0,1,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
};


#ifdef CUSTOM_FUNC_4x8b

int8_t U[]={
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,0,1,0,1,0,1,1,1,1,1,1,1,1,1,0,0,1,0,0,1,1,1,1,1,0,0,1,1,1,0,1,0,1,0,0,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,0,1,1,0,1,1,1,1,1,1,0,0,1,1,1,1,0,0,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,0,1,1,1,0,0,1,0,1,0,1,0,1,1,1,1,1,0,1,0,0,0,1,0,0,0,0,1,0,1,1,1,0,1,1,0,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,0,1,1,0,0,0,0,0,0,1,1,1,0,1,0,1,1,1,1,0,0,1,1,1,0,1,1,0,1,0,0,1,1,0,0,1,0,1,1,1,1,1,0,1,0,1,1,1,0,0,1,1,0,1,1,0,1,0,1,0,0,0,0,0,1,0,0,1,0,0,0,1,1,1,1,0,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,1,1,0,0,1,0,0,0,0,1,1,1,0,0,1,0,1,0,1,0,1,0,0,1,1,0,0,0,1,1,0,1,1,0,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,1,0,1,0,0,0,0,1,0,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,0,1,1,0,1,0,0,0,1,0,1,0,0,1,1,1,0,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,1,0,0,0,1,1,1,0,1,0,0,0,1,0,1,0,0,0,1,1,1,1,0,1,0,1,1,1,1,0,1,1,0,1,1,1,0,1,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,1,0,0,0,0,1,0,0,0,0,0,1,1,0,1,1,0,0,1,1,1,0,1,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,0,0,1,0,0,1,1,1,1,0,1,0,0,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,1,0,0,0,1,0,1,1,1,0,0,0,0,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,0,0,0,1,0,1,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,1,1,1,1,0,1,
1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,0,1,0,0,1,0,1,1,1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,1,0,1,1,0,0,1,1,1,0,0,1,0,0,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,0,1,0,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,1,1,0,0,1,0,0,0,1,1,1,1,0,0,1,0,1,0,1,0,1,0,0,1,1,0,0,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,0,1,0,1,1,1,0,0,1,0,1,1,1,0,1,1,0,1,1,1,1,1,1,1,0,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,0,1,1,1,1,0,1,0,1,0,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,0,1,1,0,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,0,1,0,1,1,0,0,1,1,0,1,1,1,0,1,1,0,0,1,0,1,1,0,0,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,0,1,0,0,1,0,1,0,1,0,1,1,1,1,1,0,0,1,1,1,0,0,0,1,0,1,1,1,0,1,1,1,0,1,1,0,1,0,1,1,0,1,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,0,1,1,1,0,0,0,0,1,1,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1,1,1,1,1,1,0,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,1,0,0,1,1,1,1,1,0,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
};

int8_t codw[]={
 4,7,5,-7,-7,-7,8,7,8,3,7,-5,10,6,-9,6,5,-9,-8,6,6,5,-2,4,8,6,-5,8,-5,7,7,-6,5,7,-6,-6,5,-6,-7,11,8,5,-6,5,-3,7,9,-8,8,7,3,-4,-3,-4,4,6,-3,-4,-7,-6,4,4,-6,3,-6,7,-7,-7,6,4,6,8,3,-8,-5,-2,-7,6,-8,6,-8,4,2,-5,5,-6,3,-8,5,-6,7,-6,5,-6,-6,-4,5,-4,-7,5,-5,-5,-4,4,-5,-4,-4,5,-5,-2,-7,-7,-5,-6,4,8,6,-7,6,-6,6,5,-5,10,8,-3,-7,-7,-8,3,-9,7,8,6,-3,7,-3,-4,6,-9,-6,-7,-6,-3,5,-5,5,-5,8,-8,9,7,3,4,-6,6,4,3,-6,-7,4,3,6,-5,11,-4,-6,9,-6,5,6,6,-4,4,-8,8,-6,6,-7,5,-6,-7,5,4,7,-8,9,-5,1,-8,-10,-4,5,-7,-6,-5,3,-7,-3,-6,4,-5,-7,4,8,-5,-8,6,6,-7,4,7,9,5,5,5,5,-7,-3,-6,10,-7,-7,-7,6,-4,-6,7,3,4,-5,10,-8,4,-7,-5,7,-3,-6,-5,-6,-6,-6,-4,-6,-5,-7,-6,-6,-9,-6,-7,-7,-7,8,-5,-3,6,-8,-4,8,-6,-7,-6,-6,-6,5,-7,-6,9,6,7,6,-4,-7,-4,7,-4,6,-9,9,-3,4,7,6,1,5,-8,-3,7,-7,6,4,6,-4,6,-5,-3,-3,-3,-5,5,8,8,6,-6,7,-3,7,3,-4,4,-5,-4,5,7,-5,-6,5,-5,7,8,-6,5,7,6,-7,-3,-3,6,6,5,1,6,8,4,-6,-3,5,6,-4,-10,4,-8,-8,-5,4,4,-1,7,-5,-4,6,-5,7,4,9,-6,5,-6,-7,5,6,-3,-5,-4,-6,-6,5,-4,-6,-5,-5,-6,-4,-8,-8,-4,-6,-6,-5,-9,6,-8,6,5,5,5,5,-5,2,5,-3,-8,4,-5,7,4,-6,-6,6,-4,-7,-7,-5,-2,-8,3,-6,-1,-4,-4,-6,-8,-7,6,-7,4,10,-5,7,11,4,-4,2,5,-3,-4,-7,-5,-9,-6,-6,-4,-4,-6,-5,-6,9,-4,-5,-3,-8,-2,-4,-4,-4,-4,-6,5,4,5,-7,-7,-3,-4,8,-6,-4,-7,-6,-5,-7,-7,8,-4,-5,-3,-4,-3,-3,-6,-3,-6,-5,-4,-5,5,-5,-3,-8,-5,-4,-5,-8,-5,-5,-6,-4,-3,-4,-5,-3,6,6,-6,-8,-3,-4,-4,-7,-2,-7,-6,-5,-4,-6,9,-6,4,-7,5,-2,-5,-5,-6,5,5,-8,7,-4,3,5,7,-9,-7,-6,-4,8,-6,4,-5,7,-7,5,-4,7,5,8,-7,6,5,6,-7,2,7,7,-7,-2,3,-5,3,6,-5,-5,4,5,6,4,5,2,5,7,-5,-4,8,4,-8,6,6,7,7,4,-4,-6,-6,3,-4,-6,-6,-2,6,-4,-5,-2,-6,-8,5,5,5,5,-6,6,5,-7,-7,-4,8,5,-5,6,7,-3,-6,-7,-5,-6,5,-6,5,-7,-4,-8,6,-5,9,4,7,-6,-6,-5,-4,-7,3,-6,1,-4,-5,-5,6,-5,4,-7,7,5,-6,-3,-5,7,-5,-9,-6,4,-5,-6,5,-4,7,8,-6,-8,3,4,-4,-4,-6,-3,-4,7,-9,7,-9,-12,-7,3,-5,6,-7,-4,-4,-6,-5,-3,-2,-5,-5,4,-6,-4,4,-7,-8,-7,-6,-7,-7,-6,-5,3,-6,-5,-4,-5,4,-3,-3,3,-7,-7,-7,-4,-10,-8,-7,-2,6,-6,-6,7,10,-5,-6,-6,-6,-5,-7,-8,-6,5,-1,-4,-6,-8,-4,-6,-6,5,-7,-7,-6,-6,-2,-3,-4,-8,-4,-3,-6,5,-4,-8,-6,-7,-6,-5,-5,-4,-5,-6,-6,-5,-9,-5,-8,-5,-7,8,-7,-8,-6,6,3,-6,-5,-4,-6,-5,-3,-6,6,7,4,6,5,5,-7,-4,-6,8,-2,-3,-4,-5,5,7,6,-6,-4,-7,-6,-4,-7,-7,-5,-3,-6,-8,4,-7,-10,6,4,-5,-7,-7,-5,-8,-4,-9,-9,-4,-6,-7,-3,-5,-6,5,-5,-6,-5,-7,-5,-8,-4,-7,-5,-7,4,-2,-5,-5,-3,-3,-5,-8,-2,6,8,-5,-3,-5,-3,-3,-7,-5,-3,-8,-7,-8,-7,-8,7,7,5,-6,-6,-3,-8,6,-5,-4,-5,-7,-5,-8,-6,5,-6,-8,-9,-5,-4,-5,-4,-7,-9,-3,-4,-7,-4,-4,-4,4,-4,2,-3,-3,-5,5,-6,-6,3,-8,-4,-2,-5,4,-8,-5,8,4,-9,-4,-6,-4,3,4,7,-5,-3,-6,-3,4,-7,-3,-6,-7,-5,-4,-5,-3,-5,-7,-6,-4,-8,-8,-5,6,6,-3,-5,-4,-5,-6,-9,-6,-5,-2,-7,-6,7,-7,-5,-6,-3,-3,-6,-6,-7,7,-4,-6,-7,-4,-7,-6,-6,-6,-5,-4,7,-9,5,-9,-6,-3,-5,-5,-6,-5,-6,-9,-3,-5,-5,-9,5,-6,-4,-6,-6,-7,-3,-5,-5,-7,-7,10,7,3,-6,-6,-4,-6,-4,6,4,-6,-3,-4,-5,-7,-7,-6,-7,-7,-9,-7,-5,5,-4,-3,-7,-7,-4,-7,-2,-6,-7,-5,-8,-4,-8,
 4,7,-5,-4,7,-4,-3,-4,-8,-8,-4,6,-1,6,-9,6,-6,2,-8,-5,-5,-6,-2,-7,-3,-5,6,8,-5,7,7,-6,5,-4,5,5,5,-6,4,11,-3,-6,-6,5,-3,-4,-2,-8,8,7,3,7,-3,-4,4,6,-3,-4,-7,5,-7,-7,-6,3,-6,7,4,-7,6,-7,-5,-3,-8,-8,6,9,4,6,-8,6,-8,-7,-9,6,-6,5,3,3,5,-6,-4,5,-6,5,-6,7,5,-4,4,-6,6,6,-4,4,-5,7,-4,-6,-5,-2,4,4,-5,-6,-7,8,-5,-7,-5,-6,-5,5,6,-1,-3,8,-7,-7,3,3,2,7,-3,-5,-3,7,-3,7,6,2,-6,-7,5,8,5,6,-6,-5,-3,3,9,-4,3,4,-6,6,-7,-8,-6,4,4,-8,6,6,0,-4,5,-2,-6,5,6,6,-4,4,-8,8,-6,-5,-7,5,5,4,5,-7,-4,3,-2,6,-10,-8,-10,7,5,-7,5,-5,-8,-7,-3,5,-7,6,4,4,8,-5,-8,-5,6,-7,4,7,9,-6,5,-6,-6,-7,8,-6,-1,-7,-7,-7,-5,-4,-6,7,3,4,-5,-1,3,-7,4,6,7,8,-6,6,5,-6,5,-4,5,6,-7,5,-6,-9,-6,-7,-7,-7,8,-5,8,6,-8,-4,8,5,-7,-6,-6,5,-6,4,-6,-2,-5,-4,6,-4,-7,-4,7,7,6,-9,-2,-3,4,-4,-5,-10,5,-8,8,7,-7,-5,4,6,7,-5,-5,-3,8,-3,6,5,8,8,6,-6,7,-3,7,-8,7,-7,6,-4,-6,7,-5,5,5,-5,-4,-3,-6,5,7,-5,-7,8,-3,-5,-5,-6,1,6,-3,4,-6,-3,5,6,-4,1,-7,3,3,-5,-7,4,10,7,-5,7,6,6,7,-7,-2,-6,-6,-6,-7,5,-5,-3,-5,7,-6,-6,5,7,5,-5,6,-6,-4,-8,3,-4,5,5,-5,-9,6,-8,-5,5,5,5,5,6,-9,-6,-3,3,-7,-5,7,4,-6,-6,-5,-4,4,-7,-5,-2,-8,3,5,10,-4,7,-6,-8,4,6,-7,4,10,-5,-4,0,4,7,2,5,8,-4,-7,-5,2,-6,-6,7,-4,-6,-5,-6,9,7,-5,-3,-8,9,-4,-4,7,-4,5,5,4,5,4,4,-3,-4,-3,5,7,-7,5,-5,-7,-7,-3,-4,-5,8,-4,8,-3,-6,-3,5,6,-4,-5,5,-5,-3,3,-5,7,-5,3,6,6,5,7,-3,7,6,-3,6,6,5,-8,-3,-4,-4,4,-2,4,5,6,-4,5,9,-6,4,-7,5,-2,6,-5,5,5,5,-8,-4,7,-8,-6,-4,2,4,-6,7,8,-6,4,-5,7,4,5,-4,7,-6,-3,-7,6,-6,6,-7,2,7,7,-7,-2,3,6,-8,-5,6,-5,4,-6,-5,4,5,2,-6,-4,6,-4,8,4,-8,-5,-5,7,7,4,-4,5,5,-8,7,-6,-6,9,6,7,6,-2,5,-8,-6,5,-6,5,-6,-5,-6,4,4,7,-3,-6,-5,6,7,8,-6,-7,-5,-6,5,-6,5,-7,7,3,6,-5,9,4,7,5,5,-5,-4,-7,3,-6,1,-4,6,-5,6,-5,4,-7,7,5,-6,-3,6,7,6,-9,5,4,-5,5,5,-4,7,8,5,-8,-8,-7,7,-4,-6,8,-4,7,2,7,-9,-12,4,-8,-5,6,-7,-4,7,-6,-5,8,-2,-5,-5,-7,-6,-4,4,4,-8,-7,-6,-7,-7,-6,-5,3,-6,-5,-4,6,4,-3,-3,3,-7,4,-7,7,-10,3,4,9,-5,5,5,7,10,-5,5,-6,-6,-5,4,-8,-6,5,10,-4,-6,3,7,-6,5,5,4,-7,-6,5,-2,8,7,3,-4,8,-6,5,7,-8,-6,-7,5,6,-5,-4,-5,5,-6,6,-9,-5,-8,6,-7,8,4,-8,-6,6,3,5,-5,-4,-6,6,-3,-6,-5,-4,4,6,-6,-6,4,7,-6,8,9,-3,7,-5,5,-4,6,-6,-4,-7,5,7,4,4,-5,-3,-6,-8,4,-7,1,6,4,6,-7,-7,-5,-8,7,-9,-9,7,-6,-7,-3,6,-6,5,6,-6,6,4,-5,3,7,4,-5,-7,4,-2,6,-5,-3,-3,6,3,9,6,8,6,8,-5,-3,-3,-7,-5,8,3,4,-8,-7,3,7,7,5,-6,5,8,3,6,6,-4,-5,4,-5,-8,5,5,-6,-8,-9,6,-4,6,-4,4,2,8,-4,-7,-4,7,-4,4,7,2,-3,-3,6,5,-6,-6,3,3,-4,-2,6,-7,3,-5,8,4,2,7,-6,-4,3,4,7,6,-3,-6,8,4,-7,-3,-6,-7,6,7,-5,8,6,-7,-6,-4,-8,3,-5,6,6,-3,6,7,6,-6,2,5,-5,9,-7,-6,7,4,-5,-6,-3,8,5,5,-7,7,-4,-6,-7,7,4,5,5,5,6,-4,7,-9,5,2,5,8,-5,6,-6,-5,-6,-9,-3,-5,6,-9,5,-6,-4,-6,-6,-7,8,6,-5,-7,-7,10,7,3,-6,5,-4,-6,-4,6,4,5,8,-4,-5,4,4,-6,-7,-7,2,-7,6,5,-4,-3,-7,-7,7,4,-2,-6,-7,-5,-8,7,-8,
 -7,-4,-5,-4,7,7,-3,-4,3,-8,7,-5,-1,6,2,-5,5,2,3,-5,-5,-6,-2,-7,-3,6,-5,-3,6,7,-4,5,-6,7,-6,-6,-6,-6,-7,11,8,5,-6,-6,-3,7,9,3,-3,-4,3,-4,8,-4,4,-5,8,7,4,5,-7,4,-6,3,-6,-4,-7,4,-5,-7,-5,8,3,3,-5,-2,4,6,3,6,3,-7,2,-5,5,-6,3,3,5,5,7,5,5,5,5,-4,5,-4,4,-6,6,6,7,4,6,-4,-4,5,6,-2,-7,-7,-5,5,4,8,-5,-7,-5,-6,6,-6,6,-1,-3,-3,4,-7,-8,3,2,-4,-3,6,-3,7,-3,-4,6,-9,-6,4,-6,8,-6,-5,-6,6,8,3,9,7,3,4,-6,-5,-7,-8,-6,-7,4,3,-5,-5,11,-4,5,9,-6,-6,6,6,-4,4,3,-3,5,-5,-7,-6,-6,4,5,4,-4,-8,-2,6,-10,-8,1,-4,-6,4,-6,6,-8,4,8,-6,4,6,4,-7,-3,-5,-8,6,6,4,4,7,9,-6,-6,5,5,-7,-3,-6,-1,-7,-7,-7,-5,-4,-6,7,3,-7,6,-1,-8,-7,-7,6,7,-3,-6,6,-6,-6,-6,-4,5,-5,-7,-6,-6,-9,-6,-7,-7,-7,8,-5,8,6,3,-4,8,5,-7,-6,5,-6,-6,-7,-6,-2,-5,7,-5,7,4,7,7,-4,-5,2,-2,8,4,7,6,-10,5,-8,-3,7,4,-5,-7,-5,7,-5,-5,8,-3,8,-5,5,8,-3,-5,-6,-4,-3,7,-8,-4,-7,-5,7,-6,7,-5,5,5,-5,-4,8,-6,5,-4,-5,-7,-3,-3,-5,6,-6,-10,6,-3,4,5,8,5,-5,-4,1,-7,-8,-8,-5,-7,4,-1,7,-5,7,-5,-5,-4,4,9,5,5,-6,4,5,-5,-3,-5,7,-6,-6,-6,7,-6,-5,6,-6,-4,-8,-8,-4,5,-6,-5,-9,6,-8,6,5,5,-6,5,-5,2,5,8,3,-7,-5,-4,-7,-6,-6,-5,7,-7,4,6,-2,-8,3,5,10,-4,7,-6,-8,-7,6,4,4,10,6,7,11,4,-4,2,5,8,-4,-7,-5,2,-6,-6,-4,-4,-6,-5,-6,9,-4,-5,-3,-8,9,-4,-4,-4,-4,-6,-6,-7,5,-7,-7,-3,-4,8,-6,7,-7,-6,-5,-7,-7,-3,-4,-5,-3,-4,-3,-3,-6,-3,-6,6,-4,-5,5,-5,-3,-8,-5,7,-5,3,-5,6,5,7,-3,-4,6,-3,6,6,-6,-8,-3,-4,-4,-7,-2,-7,5,6,-4,5,9,-6,4,-7,5,9,6,6,-6,5,5,-8,7,7,3,-6,-4,2,4,5,7,-3,-6,-7,6,-4,4,5,7,7,5,-3,-7,-5,5,-5,-7,2,7,7,-7,-2,-8,6,3,-5,6,6,-7,-6,-5,4,5,-9,5,-4,6,7,-3,-7,-8,6,-5,7,7,4,-4,5,5,-8,7,-6,-6,9,6,-4,-5,-2,-6,3,5,5,-6,-6,-6,6,5,-7,-7,7,-3,-6,-5,6,7,-3,-6,-7,-5,-6,5,5,-6,-7,-4,3,6,-5,9,-7,7,5,-6,-5,-4,-7,3,-6,1,-4,6,-5,6,-5,4,-7,7,5,-6,-3,6,7,-5,2,-6,-7,-5,5,-6,7,-4,8,-6,3,3,4,-4,-4,-6,8,-4,-4,-9,-4,-9,-12,-7,-8,-5,6,-7,-4,7,-6,-5,-3,-2,-5,-5,-7,-6,-4,4,-7,-8,-7,-6,-7,-7,-6,-5,-8,-6,-5,-4,-5,4,-3,-3,3,-7,4,-7,7,-10,-8,-7,9,6,5,5,-4,10,-5,5,-6,-6,-5,4,-8,-6,5,-1,-4,-6,-8,-4,-6,-6,5,-7,-7,-6,5,-2,-3,-4,3,-4,8,-6,5,-4,-8,-6,-7,-6,6,-5,-4,-5,-6,-6,6,-9,-5,-8,6,-7,8,4,-8,-6,6,3,-6,-5,-4,-6,6,-3,-6,-5,-4,4,-5,-6,5,4,7,5,-3,-2,-3,7,-5,5,7,6,-6,-4,4,-6,7,-7,4,-5,-3,-6,-8,4,-7,-10,-5,-7,6,-7,-7,-5,-8,7,-9,-9,7,-6,-7,-3,-5,-6,5,6,-6,-5,-7,-5,-8,7,4,-5,-7,4,-2,-5,-5,-3,8,6,3,-2,6,8,-5,-3,-5,-3,-3,-7,-5,-3,-8,-7,-8,-7,3,7,7,5,-6,-6,8,-8,6,-5,-4,-5,4,-5,-8,-6,5,-6,-8,-9,6,-4,-5,-4,-7,2,-3,-4,-7,-4,-4,-4,4,-4,2,-3,-3,6,5,-6,-6,3,-8,-4,-2,6,-7,-8,-5,8,4,-9,7,-6,-4,3,4,7,-5,-3,-6,-3,4,-7,-3,-6,-7,-5,7,-5,-3,6,-7,-6,-4,-8,3,-5,6,6,-3,6,-4,6,-6,2,-6,-5,-2,-7,-6,7,4,-5,-6,-3,8,5,5,-7,7,-4,-6,-7,7,-7,-6,-6,5,-5,-4,7,-9,5,-9,-6,8,-5,6,-6,-5,-6,-9,-3,-5,6,-9,5,-6,-4,-6,-6,-7,-3,-5,-5,-7,-7,10,7,3,-6,5,-4,-6,-4,6,4,5,8,-4,-5,4,-7,-6,-7,-7,-9,-7,6,5,-4,-3,-7,-7,7,-7,-2,-6,-7,-5,-8,7,-8,
 4,7,-5,7,-4,7,8,7,3,-8,-4,-5,10,6,-9,-5,5,2,-8,-5,6,-6,9,4,8,-5,6,8,6,-4,7,5,-6,-4,-6,-6,5,-6,-7,11,8,5,5,-6,8,-4,9,3,8,-4,-8,7,8,7,4,-5,8,7,-7,-6,4,-7,-6,-8,5,-4,-7,4,6,4,6,-3,3,-8,6,-2,4,6,-8,-5,-8,4,2,-5,5,5,3,-8,5,5,7,-6,5,5,5,7,5,7,-7,5,6,6,7,4,6,-4,-4,-6,-5,-2,-7,4,6,5,-7,-3,6,-7,-5,5,-5,5,6,10,-3,-3,4,-7,3,-8,2,-4,8,-5,-3,7,8,7,6,-9,-6,-7,5,-3,-6,-5,-6,-5,-3,-8,9,7,-8,4,-6,-5,-7,3,5,4,-7,3,-5,-5,0,-4,5,9,5,5,-5,-5,-4,4,-8,-3,-6,-5,-7,-6,-6,-7,5,-7,7,-8,-2,-5,-10,-8,-10,-4,-6,-7,5,6,3,-7,8,-6,-7,6,4,-7,-3,6,3,-5,6,-7,4,-4,-2,5,-6,-6,-6,4,8,-6,-1,-7,-7,-7,-5,-4,5,-4,3,4,-5,-1,-8,-7,-7,-5,-4,-3,-6,-5,-6,-6,-6,-4,5,-5,-7,-6,5,-9,-6,-7,-7,-7,-3,-5,8,6,-8,7,8,-6,4,-6,5,-6,5,-7,5,-2,6,7,6,7,4,7,7,-4,6,2,-2,-3,-7,-4,-5,1,-6,3,8,7,-7,6,4,-5,7,-5,-5,-3,8,-3,6,5,8,-3,-5,5,7,-3,-4,-8,-4,-7,6,-4,5,7,6,-6,-6,-5,-4,-3,5,5,-4,6,4,-3,8,6,6,5,1,6,-3,-7,5,-3,5,6,7,1,-7,-8,-8,-5,-7,-7,10,-4,-5,-4,6,-5,-4,4,-2,5,5,-6,4,5,-5,-3,-5,-4,-6,-6,-6,7,-6,-5,-5,-6,-4,-8,-8,-4,-6,-6,-5,-9,6,-8,6,-6,5,5,-6,6,2,-6,-3,-8,-7,-5,7,4,-6,-6,6,7,-7,-7,-5,9,-8,3,5,-1,-4,-4,-6,-8,-7,6,-7,-7,-1,-5,7,0,4,-4,-9,5,-3,-4,-7,-5,-9,-6,5,-4,-4,-6,-5,-6,9,-4,-5,-3,-8,-2,-4,-4,-4,-4,5,-6,-7,-6,-7,-7,-3,-4,-3,-6,-4,-7,-6,-5,-7,-7,8,-4,-5,-3,-4,-3,-3,-6,-3,-6,-5,-4,-5,-6,-5,-3,-8,-5,-4,-5,-8,-5,-5,-6,-4,-3,-4,-5,-3,-5,-5,-6,-8,-3,-4,-4,-7,-2,-7,-6,-5,-4,-6,-2,-6,-7,-7,-6,9,-5,-5,5,-6,-6,3,7,7,-8,-6,-4,-9,-7,-6,-4,8,-6,4,6,-4,4,5,-4,7,5,-3,4,6,-6,-5,-7,2,7,7,4,-2,-8,6,3,6,6,-5,-7,-6,6,-7,5,2,5,7,6,7,8,4,-8,-5,6,7,7,-7,-4,-6,-6,3,7,-6,-6,9,6,7,-5,-2,-6,3,5,-6,5,5,-6,6,-6,4,4,7,8,-6,-5,6,-4,8,-6,-7,-5,-6,5,-6,5,-7,-4,3,-5,-5,9,-7,7,-6,-6,-5,-4,-7,3,5,-10,-4,-5,-5,-5,-5,4,-7,7,5,-6,-3,-5,-4,-5,2,5,4,-5,-6,-6,-4,7,8,-6,3,3,4,-4,-4,-6,8,-4,7,-9,-4,-9,-12,-7,3,-5,6,-7,-4,-4,-6,-5,8,-2,-5,-5,4,-6,-4,4,4,-8,-7,-6,-7,-7,-6,-5,3,-6,-5,-4,-5,-7,-3,-3,3,-7,-7,-7,-4,-10,-8,-7,9,6,-6,-6,7,10,-5,-6,-6,-6,-5,-7,-8,-6,-6,-1,-4,-6,-8,-4,-6,-6,5,-7,-7,-6,-6,-2,-3,-4,-8,-4,-3,-6,5,-4,-8,-6,-7,-6,-5,-5,-4,-5,-6,-6,-5,-9,-5,-8,-5,-7,8,-7,-8,-6,6,-8,-6,-5,-4,-6,-5,-3,5,6,7,4,6,-6,-6,-7,7,5,-3,-2,-3,-4,-5,5,7,6,5,-4,-7,-6,-4,-7,-7,-5,-3,-6,-8,-7,-7,-10,-5,-7,6,-7,-7,-5,-8,-4,-9,-9,-4,-6,-7,-3,-5,-6,-6,-5,-6,-5,-7,-5,-8,-4,-7,-5,-7,-7,-2,-5,-5,-3,-3,-5,-8,-2,-5,-3,-5,-3,-5,-3,-3,-7,-5,-3,-8,-7,-8,-7,-8,-4,7,-6,-6,-6,-3,-8,6,-5,-4,-5,-7,-5,-8,-6,-6,-6,-8,-9,-5,-4,-5,-4,-7,-9,-3,-4,-7,-4,-4,-4,-7,-4,2,-3,-3,-5,-6,-6,-6,3,-8,-4,-2,-5,4,-8,-5,8,4,-9,-4,-6,-4,-8,4,7,-5,-3,-6,-3,-7,-7,-3,-6,-7,-5,-4,-5,-3,-5,-7,-6,-4,-8,-8,-5,6,6,-3,-5,-4,-5,-6,-9,-6,-5,-2,-7,-6,7,-7,-5,-6,-3,-3,-6,-6,-7,-4,-4,-6,-7,-4,-7,-6,-6,-6,-5,-4,-4,-9,5,-9,-6,-3,-5,-5,-6,-5,-6,-9,-3,-5,-5,-9,5,-6,-4,-6,-6,-7,-3,-5,-5,-7,-7,-1,7,3,-6,-6,-4,-6,-4,6,4,-6,-3,-4,-5,-7,-7,-6,-7,-7,-9,-7,-5,-6,-4,-3,-7,-7,-4,-7,-2,-6,-7,-5,-8,-4,-8,
};

#endif

void displayVectorV1( int32_t v1)
{
    printf("op V[7:0]   %d \n", (v1   <<24)>>24  );
    printf("op V[15:8]  %d \n", (v1   <<16)>>24  );
    printf("op V[23:16] %d \n", (v1   <<8 )>>24  );
    printf("op V[31:24] %d \n", (v1       )>>24  );
}

void displayVector( int32_t v1, int32_t v2, int32_t v3)
{
    printf("op V[7:0]   (%d,%d) = %d \n", (v1   <<24)>>24 , ( v2   <<24)>>24 , ( v3   <<24)>>24 );
    printf("op V[15:8]  (%d,%d) = %d \n", (v1   <<16)>>24 , ( v2   <<16)>>24 , ( v3   <<16)>>24 );
    printf("op V[23:16] (%d,%d) = %d \n", (v1   <<8 )>>24 , ( v2   <<8 )>>24 , ( v3   <<8 )>>24 );
    printf("op V[31:24] (%d,%d) = %d \n", (v1       )>>24 , ( v2       )>>24 , ( v3       )>>24 );
}

/* TEST FUNCS */ 

#ifdef CUSTOM_BASE_FUNC_8b

#define callRinstr(a,b,c) asm volatile("pl.r %0,%1,%2" \
	                            : "+r" (a) \
	                            : "r" (b), "r" (c)); 

#define callFinstr(a,b,c) asm volatile("pl.f %0,%1,%2" \
	                            : "+r" (a) \
	                            : "r" (b), "r" (c)); 

#define callSubSat(a,b,c) asm volatile("pl.subsat %0,%1,%2" \
	                            : "=r" (a) \
	                            : "r" (b), "r" (c)); 
                                
#define callAddbSat(a,b,c) asm volatile("pl.addsat %0,%1,%2" \
	                            : "=r" (a) \
	                            : "r" (b), "r" (c)); 
/*
#define callDecode(a,b,c) asm volatile("pl.decode %0,%1,%2" \
	                            : "+r" (a) \
	                            : "r" (b), "r" (c));
*/
#endif


/* Basic Functions SC Float and 32 bits */ 
#ifdef BASE_FUNC_32b

#include <math.h>

float func_f(float la,float lb)
{
    float min1 , min2 ; 
    int sign = 0 ; 

    min1 = abs(la) ; 
    min2 = abs(lb) ;

    if(min1>min2) min1=min2 ; 
    sign = (la < 0) ^ (lb < 0) ; 

    return (sign == 0 )? min1 : -min1 ; 

}

int func_r(float la,int  froozen)
{
    if(froozen)
    {
        return 0 ; 
        
    }
    else 
    {
        return (la < 0) ; 
    }
}

float func_g(int sa,float la,float lb)
{
    return ( (1-2*sa)*la+lb ) ; 
}

int func_h(int sa,int sb)
{
    return sa^sb; 
}

#endif 

/* Extended Functions SC Float and 32 bits */ 
#ifdef EXT_FUNC_32b

void node_8(int* ptr_sum, float *LLR , int N, char *fz_bits)
{ 
    if( N == 1 )
    {     
		*ptr_sum = func_r(*LLR, *fz_bits ); 
        return;
    }

    for( int x = 0 ; x < N/2; x += 1 )
        (LLR+N)[ x ] = func_f( LLR[ x ], (LLR+N/2)[ x ]) ; 
 
    // ON CALCULE LA BRANCHE GAUCHE
    node_8(ptr_sum, (LLR+N), N/2, fz_bits);

    // ON CALCULE LES G
    for( int x = 0;  x < N/2; x += 1 )
    {
        (LLR+N)[ x ] = func_g( ptr_sum[x] ,LLR[ x ], (LLR+N/2)[ x ]) ; 
    }

    // ON CALCULE LA BRANCHE DROITE
    node_8(ptr_sum+ N/2, (LLR+N), N/2,  fz_bits+ N/2 );
    
    // ON FAIT LES CALCUL DES H (XOR DES SP)
    for(int x = 0 ; x < N/2 ; x += 1 )
    {          
        ptr_sum[x] = func_h( ptr_sum[x], ptr_sum[ x + (N/2) ]); 
    }
}

void node(int* ptr_sum, float *LLR , int N, char *fz_bits)
{
    // ON CALCULE LA BRANCHE GAUCHE
    // get the node status 
    char enab1 = *fb_table_tileN++  ; 

    if(enab1==0) // r0 
    {
        // update res with G 
        for( int x = 0;  x < N/2; x += 1 )
        {
            (LLR+N)[ x ] = func_g( ptr_sum[x] ,LLR[ x ], (LLR+N/2)[ x ]) ; 
        }

    }else if (enab1==1) // r1 
    {
        // ON CALCULE LES F
        for( int x = 0 ; x < N/2; x += 1 )
        {
            (LLR+N)[ x ] = func_f( LLR[ x ], (LLR+N/2)[ x ]) ; 
            // possible opti de boucle 
            ptr_sum[x] = func_r((LLR+N)[x], 0 ); 
        }

        // update Res with G 
        for( int x = 0;  x < N/2; x += 1 )
        {
            (LLR+N)[ x ] = func_g( ptr_sum[x] ,LLR[ x ], (LLR+N/2)[ x ]) ; 
        }

    }else if (enab1==2) // REP
    {
        // Somme des LLR 
        // x > 0 ? PS => 0 
        // x < 0 ? PS => 1 

        // ON CALCULE LES F
        float tot = 0 ; 
        for( int x = 0 ; x < N/2; x += 1 )
        {
            
            (LLR+N)[ x ] = func_f( LLR[ x ], (LLR+N/2)[ x ]) ; 
            tot += (LLR+N)[x] ;
        }

        if(tot < 0 )
        {
            for( int x = 0 ; x < N/2; x += 1 )
                ptr_sum[x] = 1 ; 
        } 

        // update Res with G for next node 
        for( int x = 0;  x < N/2; x += 1 )
        {
            (LLR+N)[ x ] = func_g( ptr_sum[x] ,LLR[ x ], (LLR+N/2)[ x ]) ; 
        }


    } else if (enab1==3 ) // SPC 
    {

        int sign=0;
        float mina = 1000 , minb=1000 ; 
        int idx_min= 0 ; 
        for( int x = 0 ; x < N/2; x += 1 )
        {
            
            (LLR+N)[ x ] = func_f( LLR[ x ], (LLR+N/2)[ x ]) ; 
            // possible opti de boucle 
            // force r1 
            ptr_sum[x] = func_r((LLR+N)[x], 0 ); 
            // parité on the fly 
            sign ^= ptr_sum[x] ; 

            float a = fabs((LLR+N)[ x ]) ; 

			if(a < mina)
			{
				minb = mina;
				mina = a;
                idx_min = x ; 
			}else if(a < minb) // min1 < a < min2
				minb = a  ;
        }
            
        // printf("sign %d min %f  idx %d " ,sign,  mina,idx_min); 
        ptr_sum[idx_min]^=sign ;

        // update Res with G for next node 
        for( int x = 0;  x < N/2; x += 1 )
        {
            (LLR+N)[ x ] = func_g( ptr_sum[x] ,LLR[ x ], (LLR+N/2)[ x ]) ; 
        }


    } else // opération normale 
    {   
        if((N/2)==8){                          
                                
            // ON CALCULE LES F
            for( int x = 0 ; x < N/2; x += 1 )
            {
                (LLR+N)[ x ] = func_f( LLR[ x ], (LLR+N/2)[ x ]) ; 
            }

            // Recursif Node_8 
            node_8( ptr_sum, (LLR+N), N/2, fz_bits) ; 

            // ON CALCULE LES G
            for( int x = 0;  x < N/2; x += 1 )
            {
                (LLR+N)[ x ] = func_g( ptr_sum[x] ,LLR[ x ], (LLR+N/2)[ x ]) ; 
            }
        }
        else{
            // ON CALCULE LES F
            for( int x = 0 ; x < N/2; x += 1 )
            {

                (LLR+N)[ x ] = func_f( LLR[ x ], (LLR+N/2)[ x ]) ; 
            }
            
            node( ptr_sum, (LLR+N), N/2, fz_bits);
                
            // ON CALCULE LES G
            for( int x = 0;  x < N/2; x += 1 )
            {
                (LLR+N)[ x ] = func_g( ptr_sum[x] ,LLR[ x ], (LLR+N/2)[ x ]) ; 
            }
        }
        
    }
        

    // ON CALCULE LA BRANCHE DROITE
    // get the node status 
    char enab2 = *fb_table_tileN++  ; 
    
    if(enab2==0) // r0 
    {
        //gestion de ptr ... 

    }else if (enab2==1) // r1 
    {
        // copy leaf calc to PS  
        for( int x = 0 ; x < N/2; x += 1 )
        {
            // +N puisque ne saute pas dans un nouveau node 
            // force r0 
            (ptr_sum+N/2)[x] = func_r( (LLR+N)[x], 0 );
        }

    }else if (enab2==2) // REP
    {
        // Somme LLRS et PS update 
        float tot = 0 ; 
        for (int x = 0; x < N/2; x++)
            tot += (LLR+N)[x] ; 

        if(tot <= 0 )
        {
            for( int x = 0 ; x < N/2; x += 1 )
                (ptr_sum+N/2)[x] = 1 ; 
        } 
    }
    else if (enab2==3) // SPC
    {
        // printf("\n SPC droit \n "); 
        // parité + sign 
        int sign=0 ; 
        float mina = 1000 , minb=1000 ; 
        int idx_min= 0 ; 
        for( int x = 0 ; x < N/2; x += 1 )
        {
            // +N puisque ne saute pas dans un nouveau node 
            // force R1 (ne tiens pas compte des bits gelés )
            (ptr_sum+N/2)[x] = func_r( (LLR+N)[x], 0 );
            sign ^= (ptr_sum+N/2)[x] ; 
            float a = fabs((LLR+N)[ x ]) ; 
            
			if(a < mina)
			{
				minb = mina;
				mina = a;
                idx_min = x ; 
			}else if(a < minb) // min1 < a < min2
				minb = a  ;
        }
            
        // printf("sign %d min %f  idx %d " ,sign,  mina,idx_min);
        ptr_sum[idx_min]^=sign ;
    }
        
    else // opération normale 
    {
        if( (N/2)==8 ){
            node_8(ptr_sum+ N/2, (LLR+N), N/2,  fz_bits+ N/2 );
        }else{
            node(ptr_sum+ N/2, (LLR+N), N/2,  fz_bits+ N/2 );
        }
    }  

    // ON FAIT LES CALCUL DES H (XOR DES SP)
    for(int x = 0 ; x < N/2 ; x += 1 )
    {          
        ptr_sum[x] = func_h( ptr_sum[x], ptr_sum[ x + (N/2) ]);    
    }
}

// calcule unqiuement le premier f ,  g  et le dernier Xor(h)
void node_top(int* ptr_sum, float *LLR , int N, char *fz_bits)
{

    // if (*fb_table_tileN != 4) {
    //     printf("(EE) TOP LEVEL TILE IS FROZEN !\n");
    //     exit(0);
    // }

    fb_table_tileN+=1 ; 

    // une fois F pr la branche gauche 
    for( int x = 0 ; x < N/2; x += 1 )
    {
        (LLR+N)[ x ] = func_f( LLR[ x ], (LLR+N/2)[ x ]) ;
    }

    // tt la branche gauche 
    const int not_frozen_value = 4;
    if (*fb_table_tileN++ != not_frozen_value) {
        printf("(EE) Un truc impossible vient de se produire (1:%d)\n", *(fb_table_tileN-1));
        exit( 0 );
    } else {
        node( ptr_sum, (LLR+N), N/2, fz_bits);
    }

    // une fois G pour la branche droite   
    for( int x = 0;  x < N/2; x += 1 )
    {
        // PS sont dispo
        (LLR+N)[ x ] = func_g( ptr_sum[x] ,LLR[ x ], (LLR+N/2)[ x ]) ; 
    }

    // tt la branche droite 
    if (*fb_table_tileN++ != not_frozen_value) {
        printf("(EE) Un truc impossible vient de se produire (1:%d)\n", *(fb_table_tileN-1));
        exit( 0 );
    } else {
         node( ptr_sum+ N/2, (LLR+N), N/2,  fz_bits+ N/2 );
    }

     // ON FAIT LES CALCUL DES H (XOR DES SP)
    for(int x = 0 ; x < N/2 ; x += 1 )
    {          
        // xor
        ptr_sum[x] = func_h( ptr_sum[x], ptr_sum[ x + (N/2) ]); 
    }

}
#endif 

/* Basic Functions 8 and 16 bits RV */ 
#ifdef BASE_FUNC_8b

        int8_t func_f(int8_t la,int8_t lb)
        {
            int8_t min1 , min2 ; 
            int8_t sign = 0 ; 

            min1 = abs(la) ; 
            min2 = abs(lb) ;

            if(min1>min2) min1=min2 ; 
            sign = (la < 0) ^ (lb < 0) ; 

            return (sign == 0 )? min1 : -min1 ; 

        }
        

        int8_t func_r(int8_t la,char froozen)
        {
            if(froozen)
            {
                return 0 ;   
            }
            else 
            {
                return (la < 0) ; 
            }
        }

        int8_t sat( int16_t val)
        {
            // evaluation uniquement sur G en 16 bits 

            if( val >= 127 )
                return 127 ; 
            else if( val <= -127)
                return -127 ; 
            else 
                return val ;
        }
        
        int16_t func_g(int8_t sa,int16_t la,int16_t lb)
        {

            if ( sa==0 )
            {
                return la+lb ; 
            }
            else
            { 
                return lb-la ; 
            }
        }

   
    /* custom fonction G , doublon volontaire pour tests */ 
    __int8_t func_g_(__int8_t sa,__int16_t la,__int16_t lb)
    {

        __int8_t res ; 
        /* 
        __int16_t aprime = sa ? -la : la ; 
        callAddbSat(res,lb,aprime); 
        */
        // provide better cycle count ( less insn)
        if ( sa==0 )
        {    
            callAddbSat(res,la,lb);
        }
        else
        { 
            callSubSat(res,lb,la) ; 
        }
        return res ;
    }


#endif

/* Extended Functions 8 and 16 bits RV */ 
#ifdef EXT_FUNC_8b

void node_8(int8_t* ptr_sum, int8_t *LLR , int N, char *fz_bits)
{ 
    if( N == 1 )
    {     
        #ifdef CUSTOM_BASE_FUNC_8b
        callRinstr(*ptr_sum,*LLR, *fz_bits);
        #else 
		*ptr_sum = func_r(*LLR, *fz_bits ); 
        #endif 

        return;
    }

    for( int x = 0 ; x < N/2; x += 1 )
    {
        #ifdef CUSTOM_BASE_FUNC_8b
        callFinstr( (LLR+N)[ x ], LLR[ x ],(LLR+N/2)[ x ])  ;

        #else 
        (LLR+N)[ x ] = func_f( LLR[ x ], (LLR+N/2)[ x ]) ;
        #endif 
    }

         
    // ON CALCULE LA BRANCHE GAUCHE
    node_8(ptr_sum, (LLR+N), N/2, fz_bits);

    // ON CALCULE LES G
    for( int x = 0;  x < N/2; x += 1 )
    {
        #ifdef CUSTOM_BASE_FUNC_8b
        (LLR+N)[ x ] = func_g_( ptr_sum[x] , (__int16_t) LLR[ x ], (__int16_t) (LLR+N/2)[ x ]) ;
        // printf( "Res %d  ( %d, %d , %d ) \n", (LLR+N)[ x ],  ptr_sum[x], (__int16_t) LLR[ x ], (__int16_t) (LLR+N/2)[ x ]  ) ;

        #else 
        __int16_t temp = func_g( ptr_sum[x] , (__int16_t) LLR[ x ], (__int16_t) (LLR+N/2)[ x ]) ; 
        (LLR+N)[ x ] =sat( temp)  ;  
        #endif 
    }

    // ON CALCULE LA BRANCHE DROITE
    node_8(ptr_sum+ N/2, (LLR+N), N/2,  fz_bits+ N/2 );
    
    // ON FAIT LES CALCUL DES H (XOR DES SP)
    for(int x = 0 ; x < N/2 ; x += 1 )
    {          
        ptr_sum[x] ^=ptr_sum[ x + (N/2) ]; 
    }
}

 
void node(int8_t* ptr_sum, int8_t *LLR , int N, char *fz_bits)
{
    // ON CALCULE LA BRANCHE GAUCHE
    // get the node status 
    char enab1 = *fb_table_tileN++  ; 

    if(enab1==0) // r0 
    {
        // update res with G 
        for( int x = 0;  x < N/2; x += 1 )
        {
            #ifdef CUSTOM_BASE_FUNC_8b
            (LLR+N)[ x ] = func_g_( ptr_sum[x] , (__int16_t) LLR[ x ], (__int16_t) (LLR+N/2)[ x ]) ;
        
            #else 
            __int16_t temp = func_g( ptr_sum[x] , (__int16_t) LLR[ x ], (__int16_t) (LLR+N/2)[ x ]) ; 
            (LLR+N)[ x ] =sat( temp)  ;  
            #endif 
        }

    }else if (enab1==1) // r1 
    {
        // ON CALCULE LES F
        for( int x = 0 ; x < N/2; x += 1 )
        {
            #ifdef CUSTOM_BASE_FUNC_8b
            // opti avec pointeur sur (LLR+N)[ x ] ?? 
            callFinstr( (LLR+N)[ x ], LLR[ x ],(LLR+N/2)[ x ])  ;
            callRinstr(*ptr_sum,(LLR+N)[x], 0);

            #else 
            (LLR+N)[ x ] = func_f( LLR[ x ], (LLR+N/2)[ x ]) ; 
            ptr_sum[x] = func_r((LLR+N)[x], 0 ); 
            #endif 
        }

        // update Res with G 
        for( int x = 0;  x < N/2; x += 1 )
        {
            #ifdef CUSTOM_BASE_FUNC_8b
            (LLR+N)[ x ] = func_g_( ptr_sum[x] , (__int16_t) LLR[ x ], (__int16_t) (LLR+N/2)[ x ]) ;
            
            #else 
            __int16_t temp = func_g( ptr_sum[x] , (__int16_t) LLR[ x ], (__int16_t) (LLR+N/2)[ x ]) ; 
            (LLR+N)[ x ] =sat( temp)  ;  
            #endif 
        }

    }else if (enab1==2) // REP
    {
        // Somme des LLR 
        // x > 0 ? PS => 0 
        // x < 0 ? PS => 1 

        // ON CALCULE LES F
        int tot = 0 ; 
        for( int x = 0 ; x < N/2; x += 1 )
        {
            #ifdef CUSTOM_BASE_FUNC_8b
            callFinstr( (LLR+N)[ x ], LLR[ x ],(LLR+N/2)[ x ])  ;
            #else
            (LLR+N)[ x ] = func_f( LLR[ x ], (LLR+N/2)[ x ]) ; 
            #endif 
            tot += (LLR+N)[x] ;
        }

        if(tot < 0 )
        {
            for( int x = 0 ; x < N/2; x += 1 )
                ptr_sum[x] = 1 ; 
        } 

        // update Res with G for next node 
        for( int x = 0;  x < N/2; x += 1 )
        {
            #ifdef CUSTOM_BASE_FUNC_8b
            (LLR+N)[ x ] = func_g_( ptr_sum[x] , (__int16_t) LLR[ x ], (__int16_t) (LLR+N/2)[ x ]) ;
            
            #else 
            __int16_t temp = func_g( ptr_sum[x] , (__int16_t) LLR[ x ], (__int16_t) (LLR+N/2)[ x ]) ; 
            (LLR+N)[ x ] =sat( temp)  ;  
            #endif 
        }


    } else if (enab1==3 ) // SPC 
    {

        int8_t sign=0;
        int mina = 100 , minb= 100 ; 
        int8_t idx_min= 0 ; 
        for( int x = 0 ; x < N/2; x += 1 )
        {
            #ifdef CUSTOM_BASE_FUNC_8b
            callFinstr( (LLR+N)[ x ], LLR[ x ],(LLR+N/2)[ x ])  ;
            callRinstr(ptr_sum[x],(LLR+N)[x], 0);
            #else 
            (LLR+N)[ x ] = func_f( LLR[ x ], (LLR+N/2)[ x ]) ; 
            ptr_sum[x] = func_r((LLR+N)[x], 0 ); 
            #endif 
            
            sign ^= ptr_sum[x] ; 

            int a = abs((LLR+N)[ x ]) ; 

			if(a < mina)
			{
				minb = mina;
				mina = a;
                idx_min = x ; 
			}else if(a < minb) // min1 < a < min2
				minb = a  ;
        }
            
        // printf("sign %d min %f  idx %d " ,sign,  mina,idx_min); 
        ptr_sum[idx_min]^=sign ;

        // update Res with G for next node 
        for( int x = 0;  x < N/2; x += 1 )
        {
            #ifdef CUSTOM_BASE_FUNC_8b
            (LLR+N)[ x ] = func_g_( ptr_sum[x] , (__int16_t) LLR[ x ], (__int16_t) (LLR+N/2)[ x ]) ;
            
            #else 
            __int16_t temp = func_g( ptr_sum[x] , (__int16_t) LLR[ x ], (__int16_t) (LLR+N/2)[ x ]) ; 
            (LLR+N)[ x ] =sat( temp)  ;  
            #endif 
        }


    } else // opération normale 
    {   
        // if ici permet de mieux dérouler le code afterwards ( reduc insn reduc cycles ) ? 
        if((N/2)==8){                          
                                
            // ON CALCULE LES F
            for( int x = 0 ; x < N/2; x += 1 )
            {
                #ifdef CUSTOM_BASE_FUNC_8b
                callFinstr( (LLR+N)[ x ], LLR[ x ],(LLR+N/2)[ x ])  ;
                #else
                (LLR+N)[ x ] = func_f( LLR[ x ], (LLR+N/2)[ x ]) ; 
                #endif
            }

            // Recursif Node_8 
            node_8( ptr_sum, (LLR+N), N/2, fz_bits) ; 

            // ON CALCULE LES G
            for( int x = 0;  x < N/2; x += 1 )
            {
                #ifdef CUSTOM_BASE_FUNC_8b
                (LLR+N)[ x ] = func_g_( ptr_sum[x] , (__int16_t) LLR[ x ], (__int16_t) (LLR+N/2)[ x ]) ;
                
                #else 
                __int16_t temp = func_g( ptr_sum[x] , (__int16_t) LLR[ x ], (__int16_t) (LLR+N/2)[ x ]) ; 
                (LLR+N)[ x ] =sat( temp)  ;  
                #endif 
            }
        }
        else{
            // ON CALCULE LES F
            for( int x = 0 ; x < N/2; x += 1 )
            {
                #ifdef CUSTOM_BASE_FUNC_8b
                callFinstr( (LLR+N)[ x ], LLR[ x ],(LLR+N/2)[ x ])  ;
                #else
                (LLR+N)[ x ] = func_f( LLR[ x ], (LLR+N/2)[ x ]) ; 
                #endif
            }
            
            node( ptr_sum, (LLR+N), N/2, fz_bits);
                
            // ON CALCULE LES G
            for( int x = 0;  x < N/2; x += 1 )
            {
                #ifdef CUSTOM_BASE_FUNC_8b
                (LLR+N)[ x ] = func_g_( ptr_sum[x] , (__int16_t) LLR[ x ], (__int16_t) (LLR+N/2)[ x ]) ;
                
                #else 
                __int16_t temp = func_g( ptr_sum[x] , (__int16_t) LLR[ x ], (__int16_t) (LLR+N/2)[ x ]) ; 
                (LLR+N)[ x ] =sat( temp)  ;  
                #endif 
            }
        }
        
    }
        

    // ON CALCULE LA BRANCHE DROITE
    // get the node status 
    char enab2 = *fb_table_tileN++  ; 
    
    if(enab2==0) // r0 
    {
        //gestion de ptr ... 

    }else if (enab2==1) // r1 
    {
        // copy leaf calc to PS  
        for( int x = 0 ; x < N/2; x += 1 )
        {
            #ifdef CUSTOM_BASE_FUNC_8b
            callRinstr((ptr_sum+N/2)[x],(LLR+N)[x], 0);
            #else 
            // +N puisque ne saute pas dans un nouveau node 
            // force r1 
            (ptr_sum+N/2)[x] = func_r( (LLR+N)[x], 0 );
            #endif
        }

    }else if (enab2==2) // REP
    {
        // Somme LLRS et PS update 
        int tot = 0 ; 
        for (int x = 0; x < N/2; x++)
            tot += (LLR+N)[x] ; 

        if(tot <= 0 )
        {
            for( int x = 0 ; x < N/2; x += 1 )
                (ptr_sum+N/2)[x] = 1 ; 
        } 
    }
    else if (enab2==3) // SPC
    {
        // printf("\n SPC droit \n "); 
        // parité + sign 
        int8_t sign=0 ; 
        int mina = 100 , minb=100 ; 
        int8_t idx_min= 0 ; 
        for( int x = 0 ; x < N/2; x += 1 )
        {

            #ifdef CUSTOM_BASE_FUNC_8b
            callRinstr((ptr_sum+N/2)[x],(LLR+N)[x], 0);
            #else 
            // +N puisque ne saute pas dans un nouveau node 
            // force R1 (ne tiens pas compte des bits gelés )
            (ptr_sum+N/2)[x] = func_r( (LLR+N)[x], 0 );
            #endif 
            
            sign ^= (ptr_sum+N/2)[x] ; 
            int a = abs((LLR+N)[ x ]) ; 
            
			if(a < mina)
			{
				minb = mina;
				mina = a;
                idx_min = x ; 
			}else if(a < minb) // min1 < a < min2
				minb = a  ;
        }
            
        // printf("sign %d min %f  idx %d " ,sign,  mina,idx_min);
        ptr_sum[idx_min]^=sign ;
    }
        
    else // opération normale 
    {
        if( (N/2)==8 ){
            node_8(ptr_sum+ N/2, (LLR+N), N/2,  fz_bits+ N/2 );
        }else{
            node(ptr_sum+ N/2, (LLR+N), N/2,  fz_bits+ N/2 );
        }
    }  

    // ON FAIT LES CALCUL DES H (XOR DES SP)
    for(int x = 0 ; x < N/2 ; x += 1 )
    {          
        ptr_sum[x] ^=ptr_sum[ x + (N/2) ];    
    }
}

// calcule unqiuement le premier f ,  g  et le dernier Xor(h)
void node_top(int8_t* ptr_sum, int8_t *LLR , int N, char *fz_bits)
{

    // if (*fb_table_tileN != 4) {
    //     printf("(EE) TOP LEVEL TILE IS FROZEN !\n");
    //     exit(0);
    // }

    fb_table_tileN+=1 ; 

    // une fois F pr la branche gauche 
    for( int x = 0 ; x < N/2; x += 1 )
    {
        #ifdef CUSTOM_BASE_FUNC_8b
        callFinstr( (LLR+N)[ x ], LLR[ x ],(LLR+N/2)[ x ])  ;
        #else
        (LLR+N)[ x ] = func_f( LLR[ x ], (LLR+N/2)[ x ]) ; 
        #endif
    }

    // tt la branche gauche 
    const int not_frozen_value = 4;
    if (*fb_table_tileN++ != not_frozen_value) {
        printf("(EE) Un truc impossible vient de se produire (1:%d)\n", *(fb_table_tileN-1));
        
    } else {
        node( ptr_sum, (LLR+N), N/2, fz_bits);
    }

    // une fois G pour la branche droite   
    for( int x = 0;  x < N/2; x += 1 )
    {
        #ifdef CUSTOM_BASE_FUNC_8b
        (LLR+N)[ x ] = func_g_( ptr_sum[x] , (__int16_t) LLR[ x ], (__int16_t) (LLR+N/2)[ x ]) ;

        #else 
        __int16_t temp = func_g_( ptr_sum[x] , (__int16_t) LLR[ x ], (__int16_t) (LLR+N/2)[ x ]) ; 
        (LLR+N)[ x ] =sat( temp)  ;  
        #endif 
    }

    // tt la branche droite 
    if (*fb_table_tileN++ != not_frozen_value) {
        printf("(EE) Un truc impossible vient de se produire (1:%d)\n", *(fb_table_tileN-1));
        
    } else {
         node( ptr_sum+ N/2, (LLR+N), N/2,  fz_bits+ N/2 );
    }

     // ON FAIT LES CALCUL DES H (XOR DES SP)
    for(int x = 0 ; x < N/2 ; x += 1 )
    {          
        // xor
        ptr_sum[x] ^=ptr_sum[ x + (N/2) ]; 
    }

}

#endif

/* special SIMD4x8b fonctions */
#ifdef CUSTOM_FUNC_4x8b 

#define callRinstr(a,b,c) asm volatile("pl.r %0,%1,%2" \
	                            : "=r" (a) \
	                            : "r" (b), "r" (c)); 

#define callFinstr(a,b,c) asm volatile("pl.f %0,%1,%2" \
	                            : "=r" (a) \
	                            : "r" (b), "r" (c)); 

#define callSubSat(a,b,c) asm volatile("pl.subsat %0,%1,%2" \
	                            : "=r" (a) \
	                            : "r" (b), "r" (c)); 
                                
#define callAddSat(a,b,c) asm volatile("pl.addsat %0,%1,%2" \
	                            : "=r" (a) \
	                            : "r" (b), "r" (c)); 

#define callEval(a,b,c) asm volatile("pl.eval %0,%1,%2" \
	                            : "=r" (a) \
	                            : "r" (b),"r"(c)); 

#define callVADDREP1(a,b,c) asm volatile("pl.rep_addlow %0,%1,%2" \
	                            : "=r" (a) \
	                            : "r" (b), "r" (c)); 

#define callVADDREP2(a,b,c) asm volatile("pl.rep_addhi %0,%1,%2" \
	                            : "=r" (a) \
	                            : "r" (b), "r" (c)); 

#define callVREPSUM(a,b,c) asm volatile("pl.rep_addsign %0,%1,%2" \
	                            : "=r" (a) \
	                            : "r" (b), "r" (c)); 

#define callVSPCMIN(a,b,c) asm volatile("pl.spc_amin %0,%1,%2" \
	                            : "=r" (a) \
	                            : "r" (b), "r" (c)); 

#define callVSPCCOMP(a,b,c) asm volatile("pl.spc_acmp %0,%1,%2" \
	                            : "=r" (a) \
	                            : "r" (b), "r" (c));        

#define callVSPCUPDATE1(a,b,c) asm volatile("pl.spc_idup %0,%1,%2" \
	                            : "=r" (a) \
	                            : "r" (b), "r" (c));     

#define callVSPCUPDATE2(a,b,c) asm volatile("pl.spc_max %0,%1,%2" \
                                : "=r" (a) \
                                : "r" (b),"r"(c)); 



        
void reorder(int32_t* dest, const int8_t* src, int N) // a = sign, b = value
{
    int8_t* ptr = (int8_t*) dest;
    for (int32_t i=0; i<N; i++)
    {
        for (int32_t z = 0; z < 4; z+= 1)
        {
            ptr[(4*i) + z] = src[z * N + i];
        }
    }
}

void ireorder(int8_t* dest, int32_t* src, int N) // a = sign, b = value
{
    int8_t* ptr = (int8_t*) src;
    for (int32_t i = 0; i < N; i += 1)
    {
        for (int32_t j = 0; j < 4; j += 1)
        {
            dest[j * N + i] = ptr[4 * i + j];
        }
    }
}


int32_t func_g(int32_t sa,int32_t la,int32_t lb)
{
    // solutionée par l'utilisation du masquage mais demande de faire les 2 calculs .. 
    // modèle LDPC 

    int32_t eval ;   
    callEval(eval,sa,0) ;  

    int32_t v1,v2,vf ; 
    callAddSat(v1,la,lb) ;
    callSubSat(v2,lb,la) ; 

    v1 = v1 & ~eval ;
    v2 = v2 & eval ; 
    vf = v1 | v2 ; 

    return vf ; 
}

void node_8(int32_t* ptr_sum, int32_t *LLR , int N, char *fz_bits)
{ 
    if( N == 1 )
    {     
        callRinstr(*ptr_sum,*LLR, *fz_bits);
        return;
    }

    for( int x = 0 ; x < N/2; x += 1 )
    {
        callFinstr( (LLR+N)[ x ], LLR[ x ],(LLR+N/2)[ x ])  ;
    }

         
    // ON CALCULE LA BRANCHE GAUCHE
    node_8(ptr_sum, (LLR+N), N/2, fz_bits);

    // ON CALCULE LES G
    for( int x = 0;  x < N/2; x += 1 )
    {
        (LLR+N)[ x ] = func_g( ptr_sum[x] , LLR[ x ], (LLR+N/2)[ x ]) ;
    }

    // ON CALCULE LA BRANCHE DROITE
    node_8(ptr_sum+ N/2, (LLR+N), N/2,  fz_bits+ N/2 );
    
    // ON FAIT LES CALCUL DES H (XOR DES SP)
    for(int x = 0 ; x < N/2 ; x += 1 )
    {          
        ptr_sum[x] ^=ptr_sum[ x + (N/2) ] ; 
    }
}

void node(int32_t* ptr_sum, int32_t *LLR , int N, char *fz_bits)
{
    // ON CALCULE LA BRANCHE GAUCHE
    // get the node status 
    char enab1 = *fb_table_tileN++  ; 

    if(enab1==0) // r0 
    {
        // update res with G 
        for( int x = 0;  x < N/2; x += 1 )
        {
            (LLR+N)[ x ] = func_g( ptr_sum[x] ,  LLR[ x ],  (LLR+N/2)[ x ]) ;
        }

    }else if (enab1==1) // r1 
    {
        // ON CALCULE LES F
        for( int x = 0 ; x < N/2; x += 1 )
        {
            callFinstr( (LLR+N)[ x ], LLR[ x ],(LLR+N/2)[ x ])  ;
            callRinstr(ptr_sum[x] ,(LLR+N)[x], 0);
        }

        // update Res with G 
        for( int x = 0;  x < N/2; x += 1 )
        {
            (LLR+N)[ x ] = func_g( ptr_sum[x] ,  LLR[ x ],  (LLR+N/2)[ x ]) ;
        }

    }else if (enab1==2) // REP
    {
        // Somme des LLR 
        // x > 0 ? PS => 0 
        // x < 0 ? PS => 1 

        // ON CALCULE LES F

        // int32_t tot1 = 0 ;
        // int32_t tot2 = 0 ;
        // int32_t tot3 = 0 ;
        // int32_t tot4 = 0 ; 

        int32_t t12 = 0 ;
        int32_t t34 = 0 ;

 
        // what if saturation ( data stored sur 8 bits) ?
        // 4 totaux différents 
        // possibilité de patch HW mais risque d'etre dégeux via masquage & stuf 
        // autre solution instru custom 

 

        for( int x = 0 ; x < N/2; x += 1 )
        {
            callFinstr( (LLR+N)[ x ], LLR[ x ],(LLR+N/2)[ x ])  ;

            // VADD4x8( (4x8 tot , 4x8 LLR)


                // VADD_REP1 ( int16x2_t txx , int16x2_t txx,  4x8 LLRx)

                                // VADD4x8 ( t12 ,t12 , LLR)
                                    // t12[15:0] += LLR[7:0]
                                    // t12[31:16] += LLR[15:0]

                // VADD_REP2 ( t34 ,t34, LLR)
                                    // t34[15:0] += LLR[24:16]
                                    // t34[31:16] += LLR[31:25]


            // printf("LLR %d : %d \n",x,    (LLR+N)[ x ]) ;
            // printf("LLR %d : %d ",x,  ( (LLR+N)[x]<<24 )>>24  ) ;
            // printf("LLR %d : %d ",x,  ( (LLR+N)[x]<<16 )>>24  ) ;
            // printf("LLR %d : %d ",x,  ( (LLR+N)[x]<<8  )>>24  ) ;
            // printf("LLR %d : %d \n",x,  ( (LLR+N)[x]     )>>24  ) ;

            // tot1 += ((LLR+N)[x]<<24 )>>24 ;
            // tot2 += ((LLR+N)[x]<<16 )>>24 ;
            // tot3 += ((LLR+N)[x]<<8  )>>24 ;
            // tot4 += ((LLR+N)[x]     )>>24 ;

            callVADDREP1(t12,t12,(LLR+N)[x]);

            // printf(" vaddrep1 %d  | t1 %d | t2 %d \n",t12
            // , (t12<<16)>>16
            // , (t12)>>16
            // ); 

            callVADDREP2(t34,t34,(LLR+N)[x]); 
            // printf(" vaddrep2 %d  | t3 %d | t4 %d \n",t34
            // , (t34<<16)>>16
            // , (t34)>>16
            // ); 


        }


    //     printf("TOTs\n") ; 
    //     printf("tot1 %d \n",tot1);
    //     printf("tot2 %d \n",tot2);
    //     printf("tot3 %d \n",tot3);
    //     printf("tot4 %d \n",tot4);

    //     printf(" vaddrep1 %d  | t1 %d | t2 %d \n",t12
    //     , (t12<<16)>>16
    //     , (t12)>>16 ); 

    //     printf(" vaddrep2 %d  | t3 %d | t4 %d \n",t34
    //     , (t34<<16)>>16
    //     , (t34)>>16 ); 


    //     if(tot1<0) 
    //         sum = 1; 
    //     if(tot2<0) 
    //         sum += 1<<8;
    //     if(tot3<0) 
    //         sum += 1<<16;
    //     if(tot4<0) 
    //         sum += 1<<24;  

        /*
        sum = (tot4 < 0)<<24  | (tot3 < 0)<<16  | (tot2 < 0)<<8 | (tot1 < 0)
        */
        int32_t sum = 0 ;         
        callVREPSUM(sum,t12,t34);


        // ne faire tourner ce for que si sum est >0 . save qq instrus 
        if (sum>0)
        {            
            for(int x = 0; x < N/2; x++)
                ptr_sum[x] = sum;
        }

        // update Res with G for next node 
        for( int x = 0;  x < N/2; x += 1 )
        {
            (LLR+N)[ x ] = func_g( ptr_sum[x] , LLR[ x ],  (LLR+N/2)[ x ]) ;
        }


    } else 
    if (enab1==3 ) // SPC 
    {
        
/*
        // 4 signes 
        int32_t sign1=0 ; 
        int32_t sign2=0 ; 
        int32_t sign3=0 ; 
        int32_t sign4=0 ; 

        // section à // par 4
        int8_t mina1 = 100  ; 
        int8_t mina2 = 100  ;
        int8_t mina3 = 100  ;
        int8_t mina4 = 100  ;

        int8_t idx_min1= 0 ; 
        int8_t idx_min2= 0 ;
        int8_t idx_min3= 0 ;
        int8_t idx_min4= 0 ;

*/

        int32_t sign = 0 ;
        int32_t idx_min = 0 ;
        int32_t idx_temp = 0 ; 

        // si min est init différement de > 0, necessite également de le abs() ds les ctrls 
        int32_t min = 0x70707070;
        int32_t mask=0;
        int32_t a = 0 ; 

        
        for( int x = 0 ; x < N/2; x += 1 )
        {
            callFinstr( (LLR+N)[ x ], LLR[ x ],(LLR+N/2)[ x ])  ;
            callRinstr(ptr_sum[x],(LLR+N)[x], 0);



            // printf("LLR %d : %d \n",x,    (LLR+N)[ x ]) ;
            // printf("LLR %d : %d ",x,     ( (LLR+N)[x]<<24 )>>24  ) ;
            // printf("LLR %d : %d ",x,     ( (LLR+N)[x]<<16 )>>24  ) ;
            // printf("LLR %d : %d ",x,     ( (LLR+N)[x]<<8  )>>24  ) ;
            // printf("LLR %d : %d \n",x,   ( (LLR+N)[x]     )>>24  ) ;

            // printf("PS %d : %d \n",x,    ptr_sum[x]) ;
            // printf("PS %d : %d ",x,     ( ptr_sum[x] <<24 )>>24  ) ;
            // printf("PS %d : %d ",x,     ( ptr_sum[x] <<16 )>>24  ) ;
            // printf("PS %d : %d ",x,     ( ptr_sum[x] <<8  )>>24  ) ;
            // printf("PS %d : %d \n",x,   ( ptr_sum[x]     )>>24  ) ;

            // ne fonctionne pas puisque 4 morceaux différents 
/*
            sign1 ^= (ptr_sum[x]<<24)>>24   ;
            sign2 ^= (ptr_sum[x]<<16)>>24   ;
            sign3 ^= (ptr_sum[x]<< 8)>>24   ;
            sign4 ^= (ptr_sum[x]    )>>24   ;

            // printf("sign1 %d ",    sign1);
            // printf("sign2 %d ",    sign2);
            // printf("sign3 %d ",    sign3);
            // printf("sign4 %d \n",  sign4);

            // printf("sign %d ",     ( sign<<24 )>>24  ) ;
            // printf("sign %d ",     ( sign<<16 )>>24  ) ;
            // printf("sign %d ",     ( sign<<8  )>>24  ) ;
            // printf("sign %d \n",   ( sign     )>>24  ) ;


            int8_t a1 = abs( ((LLR+N)[ x ]<<24)>>24) ; 
            int8_t a2 = abs( ((LLR+N)[ x ]<<16)>>24) ;
            int8_t a3 = abs( ((LLR+N)[ x ]<< 8)>>24) ;
            int8_t a4 = abs( ((LLR+N)[ x ]    )>>24) ;

            
            if (a1<mina1)
            {
                mina1 = a1;
                idx_min1 = x ;     
            }

            if (a2<mina2)
            {
                mina2 = a2;
                idx_min2 = x ;     
            }

            if (a3<mina3)
            {
                mina3 = a3;
                idx_min3 = x ;     
            }

            if (a4<mina4)
            {
                mina4 = a4;
                idx_min4 = x ;     
            }         


*/
            

            sign^=ptr_sum[x] ; 

           
            callVSPCCOMP    (mask ,(LLR+N)[ x ],min) ; 
            callVSPCMIN     (min  ,(LLR+N)[ x ],min); 
            callVSPCUPDATE1 (idx_temp,mask,x ) ;
            callVSPCUPDATE2 (idx_min,idx_temp,idx_min) ; 


        }
   
        // INVERSION DE SIGNE 

        uint8_t* idx_min_ptr = (uint8_t*) idx_min ; 

        ptr_sum[idx_min_ptr[0]]^=sign ; 
        ptr_sum[idx_min_ptr[1]]^=sign ;
        ptr_sum[idx_min_ptr[2]]^=sign ;
        ptr_sum[idx_min_ptr[3]]^=sign ;

/* 
        uint8_t* sign_ptr = (uint8_t*) sign ;

        ptr_sum[idx_min_ptr[0]]^= sign_ptr[0] ; 
        ptr_sum[idx_min_ptr[1]]^= ( sign_ptr[1]<<8 ) ;
        ptr_sum[idx_min_ptr[2]]^= ( sign_ptr[2]<<16) ;
        ptr_sum[idx_min_ptr[3]]^= ( sign_ptr[3]<<24) ;
*/


/*
        printf("sign1 %d min1 %d  idx1 %d \n" ,sign1,  mina1,idx_min1);
        printf("sign %d min %d  idx %d \n" ,sign2,  mina2,idx_min2);
        printf("sign %d min %d  idx %d \n" ,sign3,  mina3,idx_min3);
        printf("sign %d min %d  idx %d \n" ,sign4,  mina4,idx_min4); 

        ptr_sum[idx_min1]^=sign1 ;
        ptr_sum[idx_min2]^=(sign2<<8) ;
        ptr_sum[idx_min3]^=(sign3<<16) ;
        ptr_sum[idx_min4]^=(sign4<<24) ;
*/



        // update Res with G for next node 
        for( int x = 0;  x < N/2; x += 1 )
        {
            (LLR+N)[ x ] = func_g( ptr_sum[x] ,  LLR[ x ],  (LLR+N/2)[ x ]) ;
        }


    } else // opération normale 
    {   
        // if ici permet de mieux dérouler le code afterwards ( reduc insn reduc cycles ) ? 
        // si Noeud inferieur n'est pas particulier 
        if((N/2)==8){                          
                                
            // ON CALCULE LES F
            for( int x = 0 ; x < N/2; x += 1 )
            {
                callFinstr( (LLR+N)[ x ], LLR[ x ],(LLR+N/2)[ x ])  ;
            }

            // Recursif Node_8 
            node_8( ptr_sum, (LLR+N), N/2, fz_bits) ; 

            // ON CALCULE LES G
            for( int x = 0;  x < N/2; x += 1 )
            {
                (LLR+N)[ x ] = func_g( ptr_sum[x] , LLR[ x ],  (LLR+N/2)[ x ]) ;
            }
        }
        else{
            // ON CALCULE LES F
            for( int x = 0 ; x < N/2; x += 1 )
            {
                callFinstr( (LLR+N)[ x ], LLR[ x ],(LLR+N/2)[ x ])  ;
            }
            
            node( ptr_sum, (LLR+N), N/2, fz_bits);
                
            // ON CALCULE LES G
            for( int x = 0;  x < N/2; x += 1 )
            {
                (LLR+N)[ x ] = func_g( ptr_sum[x] , LLR[ x ],  (LLR+N/2)[ x ]) ;
            }
        }
        
    }
        

    // ON CALCULE LA BRANCHE DROITE
    // get the node status 
    char enab2 = *fb_table_tileN++  ; 
    
    if(enab2==0) // r0 
    {
        //gestion de ptr ... 

    }else if (enab2==1) // r1 
    {
        // copy leaf calc to PS  
        for( int x = 0 ; x < N/2; x += 1 )
        {
            callRinstr((ptr_sum+N/2)[x],(LLR+N)[x], 0);
        }

    }else if (enab2==2) // REP
    {
        int32_t t12 = 0 ;
        int32_t t34 = 0 ;

        for( int x = 0 ; x < N/2; x += 1 )
        {
            callVADDREP1(t12,t12,(LLR+N)[x]);
            callVADDREP2(t34,t34,(LLR+N)[x]); 
        } 

        int32_t sum = 0 ;         
        callVREPSUM(sum,t12,t34);

        if(sum>0){    
            for (int x = 0; x < N/2; x++)
            (ptr_sum+N/2)[x] = sum ; 
        }
    }
    else if (enab2==3) // SPC
    {

/*
        int32_t sign1=0 ; 
        int32_t sign2=0 ; 
        int32_t sign3=0 ; 
        int32_t sign4=0 ; 

        int8_t idx_min1= 0 ; 
        int8_t idx_min2= 0 ;
        int8_t idx_min3= 0 ;
        int8_t idx_min4= 0 ;

                    // section à // par 4
            int8_t mina1 = 100  ; 
            int8_t mina2 = 100  ;
            int8_t mina3 = 100  ;
            int8_t mina4 = 100  ;

*/


        int32_t sign = 0 ;
        int32_t idx_min = 0 ;
        int32_t idx_temp = 0 ; 
        int32_t min = 0x70707070;
        int32_t mask=0;

        for( int x = 0 ; x < N/2; x += 1 )
        {
            callRinstr((ptr_sum+N/2)[x],(LLR+N)[x], 0);

            // ne fonctionne pas puisque 4 morceaux différents 
            sign^=ptr_sum[x] ; 

            // callVABS(a,(LLR+N)[ x ],0) ; 

            callVSPCCOMP(mask , (LLR+N)[ x ] , min ) ; 
            callVSPCMIN( min,(LLR+N)[ x ],min ); 
            callVSPCUPDATE1(idx_temp,mask,x ) ;
            callVSPCUPDATE2(idx_min,idx_temp,idx_min) ;    

        }

        uint8_t* idx_min_ptr = (uint8_t*) idx_min ; 

        ptr_sum[idx_min_ptr[0]]^=sign ; 
        ptr_sum[idx_min_ptr[1]]^=sign ;
        ptr_sum[idx_min_ptr[2]]^=sign ;
        ptr_sum[idx_min_ptr[3]]^=sign ;

/*
        ptr_sum[idx_min1]^=sign1 ;
        ptr_sum[idx_min2]^=(sign2<<8) ;
        ptr_sum[idx_min3]^=(sign3<<16) ;
        ptr_sum[idx_min4]^=(sign4<<24) ;
*/
    



    }
        
    else // opération normale 
    {
        if( (N/2)==8 ){
            node_8(ptr_sum+ N/2, (LLR+N), N/2,  fz_bits+ N/2 );
        }else{
            node(ptr_sum+ N/2, (LLR+N), N/2,  fz_bits+ N/2 );
        }
    }  

    // ON FAIT LES CALCUL DES H (XOR DES SP)
    for(int x = 0 ; x < N/2 ; x += 1 )
    {          
        ptr_sum[x] ^=ptr_sum[ x + (N/2) ];    
    }
}

// calcule unqiuement le premier f ,  g  et le dernier Xor(h)
void node_top(int32_t* ptr_sum, int32_t *LLR , int N, char *fz_bits)
{

    // if (*fb_table_tileN != 4) {
    //     printf("(EE) TOP LEVEL TILE IS FROZEN !\n");
    //     exit(0);
    // }

    fb_table_tileN+=1 ; 

    // une fois F pr la branche gauche 
    for( int x = 0 ; x < N/2; x += 1 )
    {
        callFinstr( (LLR+N)[ x ], LLR[ x ],(LLR+N/2)[ x ])  ;
    }

    // tt la branche gauche 
    const int not_frozen_value = 4;
    if (*fb_table_tileN++ != not_frozen_value) {
        printf("(EE) Un truc impossible vient de se produire (1:%d)\n", *(fb_table_tileN-1));
        
    } else {
        node( ptr_sum, (LLR+N), N/2, fz_bits);
    }

    // une fois G pour la branche droite   
    for( int x = 0;  x < N/2; x += 1 )
    {

        (LLR+N)[ x ] = func_g( ptr_sum[x] ,  LLR[ x ], (LLR+N/2)[ x ]) ;
    }

    // tt la branche droite 
    if (*fb_table_tileN++ != not_frozen_value) {
        printf("(EE) Un truc impossible vient de se produire (1:%d)\n", *(fb_table_tileN-1));
        
    } else {
         node( ptr_sum+ N/2, (LLR+N), N/2,  fz_bits+ N/2 );
    }

     // ON FAIT LES CALCUL DES H (XOR DES SP)
    for(int x = 0 ; x < N/2 ; x += 1 )
    {          
        // xor
        ptr_sum[x] ^=ptr_sum[ x + (N/2) ]; 
    }

}


#endif 
